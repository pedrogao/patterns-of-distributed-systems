import{_ as e,c as t,a4 as i,G as n,w as h,B as l,o as p,a as k}from"./chunks/framework.DDPRMxUp.js";const r="/patterns-of-distributed-systems/assets/Heartbeat._kbcBADd.png",b=JSON.parse('{"title":"心跳（HeartBeat）","description":"","frontmatter":{},"headers":[],"relativePath":"content/heartbeat.md","filePath":"content/heartbeat.md"}'),E={name:"content/heartbeat.md"};function d(g,s,o,c,y,u){const a=l("center");return p(),t("div",null,[s[1]||(s[1]=i('<h1 id="心跳-heartbeat" tabindex="-1">心跳（HeartBeat） <a class="header-anchor" href="#心跳-heartbeat" aria-label="Permalink to &quot;心跳（HeartBeat）&quot;">​</a></h1><p><strong>原文</strong></p><p><a href="https://martinfowler.com/articles/patterns-of-distributed-systems/heartbeat.html" target="_blank" rel="noreferrer">https://martinfowler.com/articles/patterns-of-distributed-systems/heartbeat.html</a></p><p>通过周期性地发送消息给所有其它服务器，表明一个服务器处于可用状态。</p><p><strong>2020.8.20</strong></p><h2 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题&quot;">​</a></h2><p>如果集群里有多个服务器，根据所用的分区和复制的模式，各个服务器都要负责存储一部分数据。及时检测出服务器的失败是很重要的，这样可以确保采用一些修正的行动，让其它服务器负责处理失败服务器对应数据的请求。</p><h2 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h2><p><img src="'+r+'" alt="心跳"></p>',9)),n(a,null,{default:h(()=>s[0]||(s[0]=[k("图1：心跳")])),_:1}),s[2]||(s[2]=i(`<p>一个服务器周期性地发送请求给所有其它的服务器，以此表明它依然活跃。选择的请求间隔应该大于服务器间的网络往返的时间。所有的服务器在检查心跳时，都要等待一个超时间隔，超时间隔应该是多个请求间隔。通常来说，</p><p>超时间隔 &gt; 请求间隔 &gt; 服务器间的网络往返时间</p><p>比如，如果服务器间的网络往返时间是 20ms，心跳可以每 100ms 发送一次，服务器检查在 1s 之后执行，这样就给了多个心跳足够的时间，不会产生漏报。如果在这个间隔里没收到心跳，就可以说发送服务器已经失效了。</p><p>无论是发送心跳的服务器，还是接收心跳的服务器，都有一个调度器，定义如下。调度器会接受一个方法，以固定的间隔执行。启动时，任务就会开始调度，执行给定的方法。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HeartBeatScheduler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">…</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HeartBeatScheduler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Logging</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ScheduledThreadPoolExecutor executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ScheduledThreadPoolExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Runnable action;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Long heartBeatInterval;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HeartBeatScheduler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Runnable </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Long </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">heartBeatIntervalMs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">          this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.action </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> action;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">          this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heartBeatInterval </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> heartBeatIntervalMs;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ScheduledFuture&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; scheduledTask;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          scheduledTask </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> executor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scheduleWithFixedDelay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HeartBeatTask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(action), heartBeatInterval, heartBeatInterval, TimeUnit.MILLISECONDS);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span></code></pre></div><p>在发送端的服务器，调度器会执行方法，发送心跳消息。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SendingServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">…</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> void sendHeartbeat() throws IOException {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      socketChannel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">blockingSend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newHeartbeatRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(serverId));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><p>在接收端的服务器，失效检测机制要启动一个类似的调度器。在固定的时间间隔，检查心跳是否收到。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AbstractFailureDetector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">…</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HeartBeatScheduler heartbeatScheduler = new HeartBeatScheduler(this::heartBeatCheck, 100l);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  abstract</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> void heartBeatCheck();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  abstract</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> void heartBeatReceived(T serverId);</span></span></code></pre></div><p>失效检测器需要有两个方法：</p><ul><li>接收服务器接收到心跳调用的方法，告诉失效检测器，心跳收到了。</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReceivingServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">…</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> void handleRequest(Message&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RequestOrResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; request) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      RequestOrResponse clientRequest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> request.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">isHeartbeatRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(clientRequest)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          HeartbeatRequest heartbeatRequest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> JsonSerDes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">deserialize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(clientRequest.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getMessageBodyJson</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), HeartbeatRequest.class);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          failureDetector.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">heartBeatReceived</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(heartbeatRequest.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getServerId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          sendResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(request);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          //processes other requests</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><ul><li>一个周期性调用的方法，检查心跳状态，检测可能的失效。</li></ul><p>什么时候将服务器标记为失效，这个实现取决于不同的评判标准。其中是有一些权衡的。总的来说，心跳间隔越小，失效检测得越快，但是，也就更有可能出现失效检测的误报。因此，心跳间隔和心跳丢失的解释是按照集群的需求来的。总的来说，分成下面两大类。</p><h3 id="小集群-比如-像raft、zookeeper等基于共识的系统" tabindex="-1">小集群，比如，像Raft、Zookeeper等基于共识的系统 <a class="header-anchor" href="#小集群-比如-像raft、zookeeper等基于共识的系统" aria-label="Permalink to &quot;小集群，比如，像Raft、Zookeeper等基于共识的系统&quot;">​</a></h3><p>在所有的共识实现中，心跳是从领导者服务器发给所有追随者服务器的。每次收到心跳，都要记录心跳到达的时间戳。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TimeoutBasedFailureDetector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">…</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  @Override</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  void heartBeatReceived(T serverId) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      Long currentTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nanoTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      heartbeatReceivedTimes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">put</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">serverId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">currentTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      markUp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">serverId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><p>如果固定的时间窗口内没有收到心跳，就可以认为领导者崩溃了，需要选出一个新的服务器成为领导者。由于进程或网络缓慢，可能会一些虚报的失效。因此，<a href="./generation-clock.html">世代时钟（Generation Clock）</a>常用来检测过期的领导者。这就给系统提供了更好的可用性，这样很短的时间周期里就能检测出崩溃。对于比较小的集群，这很适用，典型的就是有三五个节点，大多数共识实现比如 Zookeeper 或 Raft 都是这样的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TimeoutBasedFailureDetector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">…</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  @Override</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  void heartBeatCheck() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      Long now </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nanoTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      Set&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; serverIds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> heartbeatReceivedTimes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">keySet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (T </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">serverId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">serverIds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          Long lastHeartbeatReceivedTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> heartbeatReceivedTimes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(serverId);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          Long timeSinceLastHeartbeat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> now </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastHeartbeatReceivedTime;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (timeSinceLastHeartbeat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timeoutNanos) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">              markDown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(serverId);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><h4 id="技术考量" tabindex="-1">技术考量 <a class="header-anchor" href="#技术考量" aria-label="Permalink to &quot;技术考量&quot;">​</a></h4><p>采用<a href="./single-socket-channel.html">单一 Socket 通道（Single Socket Channel）</a>在服务器间通信时，有一点需要考虑，就是<a href="https://en.wikipedia.org/wiki/Head-of-line_blocking" target="_blank" rel="noreferrer">队首阻塞（head-of-line-blocking）</a>，这会让心跳消息得不到处理。这样一来，延迟就会非常长，以致于产生虚报，认为发送服务器已经宕机，即便它还在按照固定的间隔发送心跳。使用<a href="./request-pipeline.html">请求管道（Request Pipeline）</a>，可以保证服务器在发送心跳之前不必等待之前请求的应答回来。有时，使用<a href="./singular-update-queue.html">单一更新队列（Singular Update Queue）</a>，像写磁盘这样的任务，就可能会造成延迟，这可能会延迟定时中断的处理，也会延迟发送心跳。</p><p>这个问题可以通过在单独的线程中异步发送心跳来解决。类似于 <a href="https://www.consul.io/" target="_blank" rel="noreferrer">consul</a> 和 <a href="https://akka.io/" target="_blank" rel="noreferrer">akka</a> 这样的框架都会异步发送心跳。对于接收者服务器同样也是一个问题。接收服务器也要进行磁盘写，检查心跳只能在写完成后才能检查心跳，这就会造成虚报的失效检测。因此接收服务器可以使用<a href="./singular-update-queue.html">单一更新队列（Singular Update Queue）</a>，解决心跳检查机制的延迟问题。<a href="https://raft.github.io/" target="_blank" rel="noreferrer">raft</a> 的参考实现、<a href="https://github.com/logcabin/logcabin" target="_blank" rel="noreferrer">log-cabin</a> 就是这么做的。</p><p>有时，一些运行时特定事件，比如垃圾收集，会造成<a href="https://issues.apache.org/jira/browse/CASSANDRA-9183" target="_blank" rel="noreferrer">本地停顿</a>，进而造成心跳处理的延迟。这就需要有一种机制在本地暂停（可能）发生后，检查心跳处理是否发生过。一个简单的机制就是，在一段足够长的时间窗口之后（如，5s），检查是否有心跳。在这种情况下，如果在这个时间窗口内不需要标记为心跳失效，那么就进入到下一个循环。<a href="https://issues.apache.org/jira/browse/CASSANDRA-9183" target="_blank" rel="noreferrer">Cassandra 的实现</a>就是这种做法的一个很好的示例。</p><h3 id="大集群-基于-gossip-的协议" tabindex="-1">大集群，基于 Gossip 的协议 <a class="header-anchor" href="#大集群-基于-gossip-的协议" aria-label="Permalink to &quot;大集群，基于 Gossip 的协议&quot;">​</a></h3><p>前面部分描述的心跳机制，并不能扩展到大规模集群，也就是那种有几百到上千台服务器，横跨广域网的集群。在大规模集群中，有两件事要考虑：</p><ul><li>每台服务器生成的消息数量要有一个固定的限制。</li><li>心跳消息消耗的总共的带宽。它不该消耗大量的网络带宽。应该有个几百 K 字节的上限，确保即便有太多的心跳也不会影响到在集群上实际传输的数据。</li></ul><p>基于这些原因，应该避免所有节点对所有节点的心跳。在这些情况下，通常会使用失效检测器，以及 <a href="https://en.wikipedia.org/wiki/Gossip_protocol" target="_blank" rel="noreferrer">Gossip</a> 协议，在集群中传播失效信息。在失效的场景下，这些集群会采取一些行动，比如，在节点间搬运数据，因此，集群会倾向于进行正确性的检测，容忍更多的延迟（虽然是有界的）。这里的主要挑战在于，不要因为网络的延迟或进程的缓慢，造成对于节点失效的虚报。那么，一种常用的机制是，给每个进程分配一个怀疑计数，在限定的时间内，如果没有收到该进程的 Gossip 消息，则怀疑计数递增。它可以根据过去的统计信息计算出来，只有在这个怀疑计数到达配置的上限时，才将其标记为失效。</p><p>有两种主流的实现：1）Phi Accrual 的失效检测器（用于 Akka、Cassandra），2）带 Lifeguard 增强的SWIM（用于 Hashicop Consul、memberlist）。这种实现可以在有数千台机器的广域网上扩展。据说 Akka 尝试过 <a href="https://www.lightbend.com/blog/running-a-2400-akka-nodes-cluster-on-google-compute-engine" target="_blank" rel="noreferrer">2400</a> 台服务器。Hashicorp Consul 在一个群组内常规部署了几千台 consul 服务器。有一个可靠的失效检测器，可以有效地用于大规模集群部署，同时，又能提供一些一致性保证，这仍然是一个积极发展中的领域。最近在一些框架的研究看上去非常有希望，比如 <a href="https://www.usenix.org/conference/atc18/presentation/suresh" target="_blank" rel="noreferrer">Rapid</a>。</p><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><ul><li>共识实现，诸如 ZAB 或 RAFT，可以在三五个节点的集群中很好的运行，实现了基于固定时间窗口的失效检测。</li><li>Akka Actor 和 Cassandra 采用 <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.80.7427&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noreferrer">Phi Accrual 的失效检测器</a>。</li><li>Hashicorp consul 采用了基于 Gossip 的失效检测器 <a href="https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf" target="_blank" rel="noreferrer">SWIM</a>。</li></ul>`,30))])}const v=e(E,[["render",d]]);export{b as __pageData,v as default};

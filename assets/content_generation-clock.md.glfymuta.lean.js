import{_ as e,c as n,a4 as a,G as t,w as l,B as h,o as p,a as k}from"./chunks/framework.DDPRMxUp.js";const r="/patterns-of-distributed-systems/assets/generation1.Oo7tRkiH.png",E="/patterns-of-distributed-systems/assets/generation2.Fne9IQPR.png",b=JSON.parse('{"title":"世代时钟（Generation Clock）","description":"","frontmatter":{},"headers":[],"relativePath":"content/generation-clock.md","filePath":"content/generation-clock.md"}'),o={name:"content/generation-clock.md"};function d(g,s,c,y,F,u){const i=h("center");return p(),n("div",null,[s[1]||(s[1]=a(`<h1 id="世代时钟-generation-clock" tabindex="-1">世代时钟（Generation Clock） <a class="header-anchor" href="#世代时钟-generation-clock" aria-label="Permalink to &quot;世代时钟（Generation Clock）&quot;">​</a></h1><p><strong>原文</strong></p><p><a href="https://martinfowler.com/articles/patterns-of-distributed-systems/generation.html" target="_blank" rel="noreferrer">https://martinfowler.com/articles/patterns-of-distributed-systems/generation.html</a></p><p>一个单调递增的数字，表示服务器的世代。</p><p><strong>2020.8.20</strong></p><p>又称：Term、Epoch 或世代（Generation）</p><h2 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题&quot;">​</a></h2><p>在<a href="./leader-and-followers.html">领导者和追随者（Leader and Followers）</a>的构建过程中，有一种可能性，领导者临时同追随者失联了。可能是因为垃圾回收造成而暂停，也可能是临时的网络中断，这些都会让领导者进程与追随者之间失联。在这种情况下，领导者进程依旧在运行，暂停之后或是网络中断停止之后，它还是会尝试发送复制请求给追随者。这么做是有危险的，因为与此同时，集群余下的部分可能已经选出了一个新的领导者，接收来自客户端的请求。有一点非常重要，集群余下的部分要能检测出有的请求是来自原有的领导者。原有的领导者本身也要能检测出，它是临时从集群中断开了，然后，采用必要的修正动作，交出领导权。</p><h2 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h2><p>维护一个单调递增的数字，表示服务器的世代。每次选出新的领导者，这个世代都应该递增。即便服务器重启，这个世代也应该是可用的，因此，它应该存储在<a href="./write-ahead-log.html">预写日志（Write-Ahead Log）</a>每一个条目里。在<a href="./high-water-mark.html">高水位标记（High-Water Mark）</a>里，我们讨论过，追随者会使用这个信息找出日志中冲突的部分。</p><p>启动时，服务器要从日志中读取最后一个已知的世代。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReplicationModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">…</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  this.replicationState = new ReplicationState(config, wal.getLastLogEntryGeneration());</span></span></code></pre></div><p>采用<a href="./leader-and-followers.html">领导者和追随者（Leader and Followers）</a>模式，选举新的领导者选举时，服务器对这个世代的值进行递增。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReplicationModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">…</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> void startLeaderElection() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      replicationState.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setGeneration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">replicationState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">getGeneration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() + </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      registerSelfVote</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      requestVoteFrom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">followers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><p>服务器会把世代当做投票请求的一部分发给其它服务器。在这种方式下，经过了成功的领导者选举之后，所有的服务器都有了相同的世代。一旦选出新的领导者，追随者就会被告知新的世代。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">follower</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReplicationModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> void becomeFollower(int leaderId, Long generation) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      replicationState.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setGeneration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">generation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      replicationState.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setLeaderId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">leaderId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      transitionTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ServerRole</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">FOLLOWING</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><p>自此之后，领导者会在它发给追随者的每个请求中都包含这个世代信息。它也包含在发给追随者的每个<a href="./heartbeat.html">心跳（HeartBeat）</a>消息里，也包含在复制请求中。</p><p>领导者也会把世代信息持久化到<a href="./write-ahead-log.html">预写日志（Write-Ahead Log）</a>的每一个条目里。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">leader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReplicationModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Long appendToLocalLog(byte[] data) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> logEntryId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wal.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getLastLogEntryId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> logEntry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WALEntry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(logEntryId, data, EntryType.DATA, replicationState.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getGeneration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      return wal.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeEntry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">logEntry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><p>按照这种做法，它还会持久化在追随者日志中，作为<a href="./leader-and-followers.html">领导者和追随者（Leader and Followers）</a>复制机制的一部分。</p><p>如果追随者得到了一个来自已罢免领导的消息，追随者就可以告知其世代过低。追随者会给出一个失败的应答。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">follower</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReplicationModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Long currentGeneration = replicationState.getGeneration();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  if (currentGeneration &gt; replicationRequest.getGeneration()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      return new </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ReplicationResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">FAILED</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">serverId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">currentGeneration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">wal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">getLastLogEntryId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><p>当领导者得到了一个失败的应答，它就会变成追随者，期待与新的领导者建立通信。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Old </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">leader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReplicationModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  if (!response.isSucceeded()) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      stepDownIfHigherGenerationResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">response</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> stepDownIfHigherGenerationResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ReplicationResponse replicationResponse) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (replicationResponse.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getGeneration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> replicationState.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getGeneration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          becomeFollower</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, replicationResponse.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getGeneration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><p>考虑一下下面这个例子。在一个服务器集群里，leader1 是既有的领导者。集群里所有服务器的世代都是 1。leader1 持续发送心跳给追随者。leader1 产生了一次长的垃圾收集暂停，比如说，5 秒。追随者没有得到心跳，超时了，然后选举出新的领导者。新的领导者将世代递增到 2。垃圾收集暂停结束之后，leader1 持续发送请求给其它服务器。追随者和新的领导者现在都是世代 2 了，拒绝了其请求，发送一个失败应答，其中的世代是 2。leader1 处理失败的应答，退下来成为一个追随者，将世代更新成 2。</p><p><img src="`+r+'" alt="世代时钟1"><img src="'+E+'" alt="世代时钟2"></p>',26)),t(i,null,{default:l(()=>s[0]||(s[0]=[k("图1：世代")])),_:1}),s[2]||(s[2]=a('<h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><h3 id="raft" tabindex="-1">Raft <a class="header-anchor" href="#raft" aria-label="Permalink to &quot;Raft&quot;">​</a></h3><p><a href="https://raft.github.io/" target="_blank" rel="noreferrer">Raft</a> 使用了 Term 的概念标记领导者世代。</p><h3 id="zab" tabindex="-1">Zab <a class="header-anchor" href="#zab" aria-label="Permalink to &quot;Zab&quot;">​</a></h3><p>在 <a href="https://zookeeper.apache.org/doc/r3.4.13/zookeeperInternals.html#sc_atomicBroadcast" target="_blank" rel="noreferrer">Zookeeper</a> 里，每个 epoch 数是作为每个事务 ID 的一部分进行维护的。因此，每个持久化在 Zookeeper 里的事务都有一个世代，通过 epoch 表示。</p><h3 id="cassandra" tabindex="-1">Cassandra <a class="header-anchor" href="#cassandra" aria-label="Permalink to &quot;Cassandra&quot;">​</a></h3><p>在 <a href="http://cassandra.apache.org/" target="_blank" rel="noreferrer">Cassandra</a> 里，每个服务器都存储了一个世代数字，每次服务器重启时都会递增。世代信息持久化在系统的键值空间里，也作为 Gossip 消息的一部分传给其它服务器。服务器接收到 Gossip 消息之后，将它知道的世代值与 Gossip 消息的世代值进行比较。如果 Gossip 消息中世代更高，它就知道服务器重启了，然后，丢弃它维护的关于这个服务器的所有状态，请求新的状态。</p><h3 id="kafka-中的-epoch" tabindex="-1">Kafka 中的 Epoch <a class="header-anchor" href="#kafka-中的-epoch" aria-label="Permalink to &quot;Kafka 中的 Epoch&quot;">​</a></h3><p><a href="https://kafka.apache.org/" target="_blank" rel="noreferrer">Kafka</a> 每次为集群选出新的控制器，都会创建一个 epoch 数，将其存在 Zookeeper 里。epoch 会包含在集群里从控制器发到其它服务器的每个请求中。它还维护了另外一个 epoch，称为 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-101+-+Alter+Replication+Protocol+to+use+Leader+Epoch+rather+than+High+Watermark+for+Truncation" target="_blank" rel="noreferrer">LeaderEpoch</a>，以便了解一个分区的追随者是否落后于其<a href="./high-water-mark.html">高水位标记（High-Water Mark）</a>。</p>',9))])}const m=e(o,[["render",d]]);export{b as __pageData,m as default};
